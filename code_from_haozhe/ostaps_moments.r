# Author: Ostap Okhrin, Michael Rockinger, Manuel Schmid

# Date: Fri, May 22 2020

# Description:
# This document gives two function. The first one is for equations (7), (10), (12) and (13) presented in the paper "Distributional Properties of Continuous Time Processes: From CIR to Bates".
# The first function calculates the (un)conditional (co)moments of the solution of the CIR process as well as the first four unconditional moments of log-returns when assuming a Bates-like model.
# The second function calculates the first four (un)conditonal moments as well as the skewness and kurtosis for log-returns arising from the SVJD model presented in the paper "Distributional Properties of Continuous Time Processes: From CIR to Bates".

# Abstract: 
# We focus on returns defined as log-price differentials and generated by a diffusion process with stochastic volatility and jumps in prices.
# The jumps are properly compensated for this model. The stochastic volatility within this model follows the well-known CIR process.
# We present general conditional and unconditional (co-)moment formulas for the solution of this process.
# By identifying these moments with those of a non-central chi-squared distribution, we derive distributional properties in a way that signifcantly differs from the historic approaches.
# Next, we derive the conditional and unconditional characteristic functions of log-returns which allows us to generate conditional and unconditional moments.
# We provide closed form expressions for the first four unconditional moments of log-returns.


# Parameters of the functions:
# p is the order of (un)conditional moments and the first order of (un)conditional comoments
# q is the second order of (un)conditional comoments (Default 0, only required if comoments are computed)
# kappa is a CIR process parameter and controls the speed of mean reversion (must be > 0)
# theta is a CIR process parameter and controls the long-run mean (must be > 0)
# sigma is a CIR process parameter and controls the volatility (must be > 0)
# rho is a Bates process parameter and controls the correlation between spot variance and (log-)price at time t (must be >= -1 and <= 1)
# lambda is a Bates process parameter and controls the jump intensity (must be >= 0)
# muj is a Bates process parameter and controls the expected jump size
# vj is a Bates process parameter and controls the jump size variance (must be >= 0)
# t is the time index (Default NA, must be > 0 if comoments or conditional moments are computed)
# v0 is the starting value of the CIR process (Default NA, must be >= 0 if conditional (co)moments are computed)
# conditional is a Boolean which controls if conditional or unconditional (co)moments are computed (Default: TRUE)
# comoments is a Boolean which controls if the moments or comoments are computed (Default: FALSE)


#rm(list = ls())


MomentsCIR = function(p, q = 0, kappa, theta, sigma, v0 = NA, t = NA, conditional = TRUE, comoments = FALSE){

  if(p %% 1 != 0 || p < 1) stop("p must be an integer >= 1")
  if(kappa <= 0) stop("kappa must be > 0")
  if(theta <= 0) stop("theta must be > 0")
  if(sigma <= 0) stop("sigma must be > 0")
  if(!is.na(v0) && v0 < 0) stop("v0 must be >= 0")
  if(!is.na(t) && t <= 0) stop("t must be > 0") 
  if(!is.logical(conditional)) stop("conditional must be a logical")
  if(!is.logical(comoments)) stop("comoments must be a logical")
  if(conditional && is.na(v0)) stop("If conditional (co)moments should be computed, a starting value v0 is needed")
  if(conditional && is.na(t)) stop("If conditional moments should be computed, a time horizon t is needed")
  if(comoments && q == 0) stop("If comoments are TRUE, q is needed")
  if(comoments && (q < 1 || q %% 1 != 0 )) stop("q must be an integer >= 1")
  if(comoments && is.na(t)) stop("If comoments are TRUE, a lag t is needed")
  
  aFun = function(p, kappa, v0){v0^(p - 1)/kappa}
  bFun = function(kappa, t){exp(kappa * t) - 1}
  cFun = function(p, kappa, theta, sigma){(p - 1) * (kappa * theta + 0.5 * (p - 2) * sigma^2)}
  IFun = function(k, kappa, t){bFun(kappa, t)^k / (factorial(k) * kappa^(k-1))}
  mFun = function(k, p, kappa, theta, sigma, v0){ 
    res = c()
    for(i in 1:length(k)){
      if(k[i] == 0){
        res[i] = 0
      }else{
       res[i] = aFun(p - k[i], kappa, v0) * prod(cFun((p - k[i] + 1):p, kappa, theta, sigma)) 
      } 
    }
    return(res)
  }  
  nuFun = function(p, kappa, theta, sigma, v0, t){ 
    aFun(p, kappa, v0) * bFun(kappa, t) + sum(mFun(0:(p - 1), p, kappa, theta, sigma, v0) * IFun(1:p, kappa, t)) 
  } 
  
  if(conditional && !comoments){
    
    Evp.v0 = function(p, kappa, theta, sigma, v0, t){
      res = c()
      for(i in 1:length(p)){
        res[i] = exp(-p[i] * kappa * t) * (v0^p[i] + cFun(p[i] + 1, kappa, theta, sigma) * nuFun(p[i], kappa, theta, sigma, v0, t))
      }
      names(res) = paste0("Evt^",p,"|v0")
      return(res)
    }
    
  Evp.v0(p, kappa, theta, sigma, v0, t)  
    
  
  }else if(conditional && comoments){
    
    Evp.v0 = function(p, kappa, theta, sigma, v0, t){
      res = c()
      for(i in 1:length(p)){
        res[i] = exp(-p[i] * kappa * t) * (v0^p[i] + cFun(p[i] + 1, kappa, theta, sigma) * nuFun(p[i], kappa, theta, sigma, v0, t))
      }
      return(res)
    }
    
    Evpvq.v0 = function(p, q, kappa, theta, sigma, v0, t){
      res = matrix(NA, nrow = length(p), ncol = length(q))
      for(i in 1:length(p)){
        for(j in 1:length(q)){
          res[i,j] = v0^p[i] * Evp.v0(p = q[j], kappa, theta, sigma, v0, t)
        }
      }
      colnames(res) = paste0("q = ",q)
      rownames(res) = paste0("p = ",p)
      return(res)
    }
    
    Evpvq.v0(p, q, kappa, theta, sigma, v0, t)
    
  }else if(!conditional && !comoments){
  
    Evp = function(p, kappa, theta, sigma, v0){
        res = c()
        for(i in 1:length(p)){
          if(p[i] == 1){
            res[i] = cFun(2, kappa, theta, sigma) * aFun(1, kappa, v0)
          }else{
            res[i] = cFun(p[i] + 1, kappa, theta, sigma) * mFun(p[i] - 1, p[i], kappa, theta, sigma, v0) / (factorial(p[i]) * kappa^(p[i] - 1))
          }
        }
        names(res) = paste0("Evt^",p)
        return(res)
    }    
  
    Evp(p, kappa, theta, sigma, v0)
    
  }else if(!conditional && comoments){
    
    Evp = function(p, kappa, theta, sigma, v0){
      res = c()
      for(i in 1:length(p)){
        if(p[i] == 1){
          res[i] = cFun(2, kappa, theta, sigma) * aFun(1, kappa, v0)
        }else{
          res[i] = cFun(p[i] + 1, kappa, theta, sigma) * mFun(p[i] - 1, p[i], kappa, theta, sigma, v0) / (factorial(p[i]) * kappa^(p[i] - 1))
        }
      }
      return(res)
    }  
    
    
    Evp.m = function(k, p, q, kappa, theta, sigma, v0, t){ 
      res = c()
      for(i in 1:length(k)){
        if(k[i] == 0){
          res[i] = 0
        }else{
          res[i] = Evp(p + q - k[i] - 1, kappa, theta, sigma, v0) / kappa * prod(cFun((q - k[i] + 1):q, kappa, theta, sigma))
        }  
      }
      return(res)
    }
    
    Evp.nuq = function(p, q, kappa, theta, sigma, v0, t){  
      Evp(p+q-1, kappa, theta, sigma, v0) * bFun(kappa, t) / kappa + sum(Evp.m(0:(q-1), p , q, kappa, theta, sigma, v0)*IFun(1:q, kappa, t))
    }
    
    Evpvq = function(p, q, kappa, theta, sigma, v0, t){
      res = matrix(NA, nrow = length(p), ncol = length(q))
      rownames(res) = paste(p)
      colnames(res) = paste(q)
      for(i in 1:length(p)){
        for(j in 1:length(q)){
          res[i,j] = exp(-q[j] * kappa * t) * (Evp(p[i] + q[j], kappa, theta, sigma, v0) + cFun(q[j] + 1, kappa, theta, sigma) * Evp.nuq(p[i], q[j], kappa, theta, sigma, v0, t))
        }
      }
      colnames(res) = paste0("q = ",q)
      rownames(res) = paste0("p = ",p)
      return(res)
    } 
    
    Evpvq(p, q, kappa, theta, sigma, v0, t)
    
  }  

}


MomentsBates = function(mu, kappa, theta, sigma, rho, lambda, muj, vj, t, v0 = NA, conditional = TRUE){
  
  
  if(kappa <= 0) stop("kappa must be > 0")
  if(theta <= 0) stop("theta must be > 0")
  if(sigma <= 0) stop("sigma must be > 0")
  if(rho < - 1 || 1 < rho) stop("rho must be >= -1 or <= 1") 
  if(lambda < 0) stop("lambda must be >= 0")
  if(vj < 0) stop("vj must be >= 0")
  if(t <= 0) stop("t must be > 0") 
  if(!is.logical(conditional)) stop("conditional must be a logical")
  if(conditional && is.na(v0)) stop("If conditional moments should be computed, a starting value v0 is needed")
  
  if(conditional){
    
    Ert1.v0 = (2 * t * kappa * mu + theta - t * kappa * theta - v0 + (-theta + v0) / exp(t * kappa))/(2 * kappa)
    
    Ert2.v0 = (2 * t^2 * exp(2 * t * kappa) * kappa^3 * (- 2 * mu + theta)^2 - (-1 + exp(t * kappa)) * (exp(t * kappa) * (-2 * kappa * (rho * sigma * (8 * theta - 4 * v0) +
              (theta - v0)^2) + sigma^2 * (5 * theta - 2 * v0) + 8 * kappa^2 * (theta - v0)) + sigma^2 * (theta - 2 * v0) + 2 * kappa * (theta - v0)^2) +                                                                                                
              2 * t * exp(t * kappa) * kappa * (2 * (sigma^2 + kappa * (-2 * (mu + rho * sigma) + theta)) * (theta - v0) + exp(t * kappa) *(sigma^2 * theta + kappa ^2 * (4 * theta + lambda * vj * (4 + vj)) +                                                                                               
              2 * kappa * (2 * mu * (theta - v0) + theta * (-2 * rho * sigma - theta + v0)))) - 8 * t * exp(2 * t * kappa) * kappa^3 * lambda * (vj - log(1 + muj)) * log(1 + muj)) /
              (8 * exp(2 * t * kappa) * kappa^3)
    
    Ert3.v0 = (2 * t^3 * exp(3 * t * kappa)* kappa^5 * (2 * mu - theta)^3 + 6 * t^2 * exp(2 * t * kappa) * kappa^2 * ( - ((sigma^2 + kappa * (-2 * (mu + rho * sigma) + theta))^2 * (theta - v0)) +
              exp(t * kappa) * kappa * (2 * mu - theta) * ( sigma^2 * theta + kappa^2 * (4 * theta + lambda * vj * (4 + vj)) + kappa * (2 * mu * (theta - v0) + theta * (-4 * rho * sigma - theta + v0)))) -   
              t * exp(t * kappa) * kappa * (-3 * (-2 * sigma^2 + kappa * (2 * mu + 4 * rho * sigma - theta)) * (sigma^2 * (theta - 2 * v0) + 2 * kappa * (theta - v0)^2) -   
              6 * exp(t * kappa) * (kappa^3 * (8 * mu + 8 * rho * sigma - 8 * theta - lambda * vj * (4 + vj)) * (theta - v0) +   
              sigma^4 * (-3 * theta + v0) + kappa * sigma^2 * (4 * mu * theta + 16 * rho * sigma * theta - theta^2 - 8 * rho * sigma * v0 - 3 * theta * v0 + 2 * v0^2) +
              2 * kappa^2 * (theta * (-4 * sigma * (sigma + 2 * rho * (mu + rho * sigma)) - 2 * (mu - 2 * rho * sigma) * theta + theta^2) +
              2 * (2 * sigma * (sigma + rho * (mu + rho * sigma)) + 2 * mu * theta - theta^2) * v0 + (-2 * (mu + rho * sigma) + theta) * v0^2)) +
              exp(2 * t * kappa) * (6 * sigma^4 *theta + 2* kappa^4 * lambda * vj^2 * (12 + vj) - 6 * kappa^2 * (2 * mu * (rho * sigma * (8 * theta - 4*v0) + (theta - v0)^2) -
              theta * ((4 + 8 * rho^2) * sigma^2 + 4 * rho * sigma * (3 * theta - 2 * v0) + (theta - v0)^2)) - 6 * kappa^3 * (8 * rho * sigma * theta + (8 * theta + lambda * vj * (4 + vj)) * (theta - v0) + 8 * mu * (-theta + v0)) -
              3 * kappa * sigma^2 * (theta * (12 * rho * sigma + 7 * theta - 4 * v0) + mu * (-10 * theta + 4 * v0)))) - (-1 + exp(t * kappa)) * (-(sigma^4 * (theta - 3 * v0)) - 3 * kappa * sigma^2 * (theta - 2 * v0) * (theta - v0) -   
              2 * kappa^2 * (theta - v0)^3 + exp(t * kappa) * (theta * (sigma^2 + 2 * kappa * theta) * (-12 * kappa^2 - 7 * sigma^2 + 2 * kappa * (12 * rho * sigma + theta)) + 
              3 * (sigma^2 + 2 * kappa * theta) * (8 * kappa^2 + 3 * sigma^2 - 2 * kappa * (6 * rho * sigma + theta)) * v0 +  12 * kappa^2 * (-2 * kappa + 2 * rho * sigma + theta) * v0^2 - 4 * kappa^2 * v0^3) +    
              exp(2 * t * kappa) * (24 * kappa^3 * (rho * sigma * (4 * theta - 2 * v0) + (theta - v0)^2) + 2 * sigma^4 * (-11 * theta + 3 * v0) + 3 * kappa * sigma^2 * (5 * theta * (8 * rho * sigma + theta) - (12 * rho * sigma + 7 * theta) * v0 + 2 * v0^2) +   
              2 * kappa^2 * (- (theta - v0)^3 + 6 * sigma^2 * (-5 * theta - 12 * rho^2 * theta + 2 * v0 + 4 * rho^2 * v0) - 12 * rho * sigma * (2 * theta^2 - 3 * theta * v0 + v0^2)))) - 
              12 * t * exp(2 * t * kappa) * kappa^4 * lambda * vj * (-2 * theta + exp(t * kappa) * (kappa * (-4 + 4 * t * mu - 2 * t * theta - vj) + 2*(theta - v0)) + 2 * v0) * log(1 + muj) + 
              24 * t * exp(2 * t * kappa) * kappa^4 * lambda * (-theta + v0 - exp(t * kappa) * (-theta + t * kappa * (-2 * mu + theta) + kappa * vj + v0)) * log(1 + muj)^2 + 
              16 * t * exp(3 * t * kappa) * kappa^5 * lambda * log(1 + muj)^3) / (16 * exp(3 * t * kappa) * kappa^5)      
          
    Ert4.v0 = (3 * sigma^6 * (theta - 4 * v0) + 4 * kappa^3 * (-theta + exp(t * kappa) * (t * kappa * (2 * mu - theta) + theta - v0) +  v0)^4 +
              8 * exp(3 * t * kappa) * sigma^2 * (-16 * t^2 * kappa^6 * rho^2 * (-3 + t * rho * sigma) * (theta - v0) + 3 * sigma^4 * (7 * theta + 2 * v0) + 
              2 * kappa^3 * sigma * ((-192 * (rho + rho^3) + 6 * t * (9 + 40 * rho^2) * sigma - 42 * t^2 * rho * sigma^2 + t^3 * sigma^3) * theta + 
              (48 * rho^3 - 18 * t * (1 + 4 * rho^2) * sigma + 24 * t^2 * rho * sigma^2 - t^3 * sigma^3) * v0) + 
              12 * kappa^4 * ((4 + 24 * rho^2 - 8 * t * rho * (4 + 3 * rho^2) * sigma + t^2 * (3 + 14 * rho^2) * sigma^2 - t^3 * rho * sigma^3) * theta +   
              (-8 * rho^2 + 8 * t * rho * (2 + rho^2) * sigma - t^2 * (3 + 8 * rho^2) * sigma^2 + t^3 * rho * sigma^3) * v0) + 
              6 * kappa^2 * sigma^2 * ((15 + 80 * rho^2 - 35 * t * rho * sigma + 2 * t^2 * sigma^2) * theta + (3 + t * sigma * (7 * rho - t * sigma)) * v0) +  
              24 * t * kappa^5 * ((2 + 8 * rho^2 - 4 * t * (rho + rho^3) * sigma + t^2 * rho^2 * sigma^2) * theta +  
              (-2 + rho * (4 * t * sigma + rho * (-4 + t * sigma * (2 * rho - t * sigma)))) * v0) + 3 * kappa * sigma^3 * (t * sigma * (9 * theta - v0) - 10 * rho * (6 * theta + v0))) +                        
              12 * exp(2 * t * kappa) * sigma^2 * (sigma^4 * (7 * theta - 4 * v0) + 8 * kappa^4 * (1 + 2 * t * rho * sigma * (-2 + t * rho * sigma)) * (theta - 2 * v0) + 
              4 * kappa^2 * sigma^2 * ((6 + 20 * rho^2 - 14 * t * rho * sigma + t^2 * sigma^2) * theta - 2 * (3 + 12 * rho^2 - 10 * t * rho * sigma + t^2 * sigma^2) * v0) -                                       
              8 * kappa^3 * sigma * ((-3 * t * sigma + 2 * rho * (4 + t * sigma * (-4 * rho + t * sigma))) * theta + 2 * (3 * t * sigma + 2 * rho * (-3 + t * sigma * (3 * rho - t * sigma))) * v0) +
              2 * kappa * sigma^3 * (t * sigma * (5 * theta - 6 * v0) + 4 * rho * (-6 * theta + 5 * v0))) + 24 * exp(t * kappa) * sigma^4 * (-2 * kappa^2 * (-1 + t * rho * sigma) * (theta - 3 * v0) +  
              sigma^2 * (theta - 2 * v0) + kappa * sigma * (t * sigma * (theta - 3 * v0) + rho * (-4 * theta + 10 * v0))) + exp(4 * t * kappa) * (192 * t * kappa^5 * (1 + 4 * rho^2) * sigma^2 * theta +                          
              4 * t * kappa^7 * lambda * vj^2 * (48 + vj * (24 + vj)) + 12 * kappa * sigma^5 * (5 * t * sigma * theta + 8 * rho * (22 * theta - 5 * v0)) + 3 * sigma^6 * (-93 * theta + 20 * v0) +  
              96 * kappa^3 * sigma^3 * ((3 * t * sigma + 4 * rho * (10 + 8 * rho^2 + 3 * t * rho * sigma)) * theta - 4 * rho * (3 + 2 * rho^2) * v0) - 
              96 * kappa^2 * sigma^4 * ((11 + 50 * rho^2 + 5 * t * rho * sigma) * theta - 3 * (v0 + 4 * rho^2 * v0)) -   
              96 * kappa^4 * sigma^2 * ((5 + 4 * rho * (6 * rho + t * (3 + 2 * rho^2) * sigma)) * theta - 2 * (v0 + 4 * rho^2 * v0))) - 
              32 * t * exp(4 * t * kappa) * kappa^7 * lambda * vj^2 * (12 + vj) * log(1 + muj) + 96 * t * exp(4 * t * kappa) * kappa^7 * lambda * vj * (4 + vj) * log(1 + muj)^2  - 
              128 * t * exp(4 * t * kappa) * kappa^7 * lambda * vj * log(1 + muj)^3 + 64 * t * exp(4 * t * kappa) * kappa^7 * lambda * log(1 + muj)^4 + 
              12 * kappa^2 * (-theta + exp(t * kappa) * (t * kappa * (2 * mu - theta) + theta - v0) + v0)^2 * (sigma^2 * (theta - 2 * v0) + 
              exp(2 * t * kappa) * (2 * t * kappa^3 * (4 * theta + lambda * vj * (4 + vj)) - 8 * kappa^2 * (theta + t * rho * sigma * theta - v0) + 
              sigma^2 * (-5 * theta + 2 * v0) + 2 * kappa * sigma * (8 * rho * theta + t * sigma * theta - 4 * rho * v0)) +                         
              4 * exp(t * kappa) * (sigma^2 * theta - 2 * kappa^2 * (-1 + t * rho * sigma) * (theta - v0) + kappa * sigma * (t * sigma * (theta - v0) + 2 * rho * (-2 * theta + v0))) -                         
              8 * t * exp(2 * t * kappa) * kappa^3 * lambda * (vj - log(1 + muj)) * log(1 + muj)) + 
              3 * kappa * (sigma^2 * (theta - 2 * v0) + exp(2 * t * kappa) * (2 * t * kappa^3 * (4 * theta + lambda * vj * (4 + vj)) - 8 * kappa^2 * (theta + t * rho * sigma * theta - v0) + 
              sigma^2 * (-5 * theta + 2 * v0) + 2 * kappa * sigma * (8 * rho * theta + t * sigma * theta - 4 * rho * v0)) + 4 * exp(t * kappa) * (sigma^2 * theta - 2 * kappa^2 * (-1 + t * rho * sigma) * (theta - v0) +                                                                     
              kappa * sigma * (t * sigma * (theta - v0) + 2 * rho * (-2 * theta + v0))) - 8 * t * exp(2 * t * kappa) * kappa^3 * lambda * (vj - log(1 + muj)) * log(1 + muj))^2 -
              8 * kappa * (-theta + exp(t * kappa) * (t * kappa * (2 * mu - theta) + theta - v0) + v0) * (sigma^4 * (theta - 3 * v0) + 3 * exp(2 * t * kappa) * sigma * ((-16 * kappa^3 * (2 + t * kappa) * rho +  
              8 * kappa^2 * (2 + 2 * t * kappa + (6 + t * kappa * (4 + t * kappa)) * rho^2) * sigma - 8 * kappa * (2 + t * kappa)^2 * rho * sigma^2 +
              (5 + 2 * t * kappa * (3 + t * kappa)) * sigma^3) * theta + (16 * kappa^3 * (1 + t * kappa) * rho - 8 * kappa^2 * (2 * t * kappa + (2 + t * kappa * (2 + t * kappa)) * rho^2)*sigma + 
              8 * t * kappa^2 * (2 + t * kappa) * rho * sigma^2 + (1 - 2 * t * kappa * (1 + t * kappa)) * sigma^3) * v0) + 6 * exp(t * kappa) * sigma^2 * (-2 * kappa^2 * (-1 + t * rho * sigma) * (theta - 2*v0) +                                                              
              sigma^2 * (theta - v0) + kappa * sigma * (t * sigma * (theta - 2 * v0) + rho * (-4 * theta + 6 * v0))) + 2 * exp(3 * t * kappa) * (-24 * t * kappa^4 * rho * sigma * theta + t * kappa^5 * lambda * vj^2 * (12 + vj) +                                                                                                                                                               
              sigma^4 * (-11 * theta + 3 * v0) + 3 * kappa * sigma^3 * (20 * rho * theta + t * sigma * theta - 6 * rho * v0) + 
              12 * kappa^3 * sigma * (4 * rho * theta + t * sigma * theta + 2 * t * rho^2 * sigma * theta - 2 * rho * v0) - 6 * kappa^2 * sigma^2 * ((5 + 3 * rho * (4 * rho + t * sigma)) * theta - 2 * (v0 + 2 * rho^2 * v0))) -  
              4 * t * exp(3 * t * kappa) * kappa^5 * lambda * log(1 + muj)* (3 * vj * (4 + vj) - 6 * vj * log(1 + muj) + 4 * log(1 +muj)^2))) / (64 * exp(4 * t * kappa) * kappa^7)   
    
    
    Varrt.v0 = (sigma^2 * (theta - 2*v0) + 4 * exp(kappa * t) * (sigma^2 * theta - 2 * kappa^2 * (-1 + t * rho * sigma) * (theta - v0) + kappa * sigma * (t * sigma * (theta - v0) + 2 * rho*(-2 * theta + v0))) + 
               exp(2 * kappa * t) * (2 * t * kappa^3 * (4 * theta + lambda * vj * (4 + vj)) - 8 * kappa^2 * (theta + t * rho * sigma * theta - v0) + sigma^2 * (-5 * theta + 2 * v0) +
               2 * kappa * sigma * (8 * rho * theta + t * sigma * theta - 4 * rho * v0) + 8 * t * kappa^3 * lambda * log(1 + muj) * (-vj + log(1 + muj)))) / (8 * exp( 2 * kappa * t) * kappa^3)                                                                
                                                                                                                
    
    Skewrt.v0 = -((sqrt(2)*(sigma^4*(theta - 3*v0) + 3*exp(2 * t * kappa)*sigma*((-16*kappa^3*(2 + t*kappa)*rho + 8*kappa^2*(2 + 2*t*kappa + (6 + t*kappa*(4 + t*kappa))*rho^2)*sigma - 
                8*kappa*(2 + t*kappa)^2*rho*sigma^2 + (5 + 2*t*kappa*(3 + t*kappa))*sigma^3)*theta + (16*kappa^3*(1 + t*kappa)*rho - 8*kappa^2*(2*t*kappa + (2 + t*kappa*(2 + t*kappa))*rho^2)*sigma + 8*t*kappa^2*(2 + t*kappa)*rho*sigma^2 + 
                (1 - 2*t*kappa*(1 + t*kappa))*sigma^3)*v0) + 6*exp(t * kappa)*sigma^2*(-2*kappa^2*(-1 + t*rho*sigma)*(theta - 2*v0) + sigma^2*(theta - v0) + kappa*sigma*(t*sigma*(theta - 2*v0) + rho*(-4*theta + 6*v0))) + 
                2*exp(3 * t * kappa)*(-24*t*kappa^4*rho*sigma*theta + t*kappa^5*lambda*vj^2*(12 + vj) + sigma^4*(-11*theta + 3*v0) + 3*kappa*sigma^3*(20*rho*theta + t*sigma*theta - 6*rho*v0) + 
                12*kappa^3*sigma*(4*rho*theta + t*sigma*theta + 2*t*rho^2*sigma*theta - 2*rho*v0) - 6*kappa^2*sigma^2*((5 + 3*rho*(4*rho + t*sigma))*theta - 2*(v0 + 2*rho^2*v0))) - 
                4*t*exp(3 * t * kappa)*kappa^5*lambda*log(1 + muj)*(3*vj*(4 + vj) - 6*vj*log(1 + muj) + 4*log(1+muj)^2)))/
                (exp(3 * t * kappa)*kappa^5*((sigma^2*(theta - 2*v0) + 4*exp(t * kappa)*(sigma^2*theta - 2*kappa^2*(-1 + t*rho*sigma)*(theta - v0) + kappa*sigma*(t*sigma*(theta - v0) + 2*rho*(-2*theta + v0))) + 
                exp(2 * t * kappa)*(2*t*kappa^3*(4*theta + lambda*vj*(4 + vj)) - 8*kappa^2*(theta + t*rho*sigma*theta - v0) + sigma^2*(-5*theta + 2*v0) + 2*kappa*sigma*(8*rho*theta + t*sigma*theta - 4*rho*v0) + 
                8*t*kappa^3*lambda*log(1 + muj)*(-vj + log(1 + muj))))/(exp(2 * t * kappa)*kappa^3))^1.5))
    
   Kurtrt.v0 = (exp(4 * t * kappa) * (-12 * kappa^3 * (2 * t * kappa * mu + theta - t * kappa * theta - v0 + (-theta + v0) / exp(t * kappa))^4 + 
               (12 * kappa^2 * (2 * t * kappa * mu + theta - t * kappa * theta - v0 + (-theta + v0) / exp(t * kappa))^2  * (2 * t^2 * exp(2 * t * kappa)* kappa^3 * (- 2 * mu + theta)^2 -
               (-1 + exp(t * kappa))*(exp(t * kappa)* (-2 * kappa * (rho * sigma * (8 * theta - 4 * v0) + (theta - v0)^2) + sigma^2 * (5 * theta - 2 * v0) + 8 * kappa^2 * (theta - v0)) + sigma^2 * (theta - 2 * v0) + 2 * kappa * (theta - v0)^2) + 
               2 * t * exp(t * kappa) * kappa * (2 * (sigma^2 + kappa * (-2 * (mu + rho * sigma) + theta)) * (theta - v0) + exp(t * kappa) * (sigma^2 * theta + kappa^2 * (4 * theta + lambda * vj * (4 + vj)) + 
               2 * kappa * (2 * mu * (theta - v0) + theta * (-2 * rho * sigma - theta + v0)))) - 8 * t * exp(2 * t * kappa) * kappa^3 * lambda * (vj - log(1 + muj)) * log(1 + muj)))/ exp(2 * t * kappa) - 
               (8 * kappa * (2 * t * kappa * mu + theta - t * kappa * theta - v0 + (-theta + v0) / exp(t * kappa))* (2 * t^3 * exp(3 * t * kappa) * kappa^5 * (2 * mu - theta)^3 + 
               6 * t^2 * exp(2 * t * kappa) * kappa^2 * (-((sigma^2 + kappa * (-2 * (mu + rho * sigma) + theta))^2 * (theta - v0)) + exp(t * kappa) * kappa * (2 * mu - theta) * (sigma^2 * theta + kappa^2 * (4 * theta + lambda * vj * (4 + vj)) + 
               kappa * (2 * mu * (theta - v0) + theta * (-4 * rho * sigma - theta + v0)))) - t * exp(t * kappa) * kappa * (-3 * (-2 * sigma^2 + kappa * (2 * mu + 4 * rho * sigma - theta)) * (sigma^2 * (theta - 2 * v0) + 2 * kappa * (theta - v0)^2) - 
               6 * exp(t * kappa) * (kappa^3 * (8 * mu + 8 * rho * sigma - 8 * theta - lambda * vj * (4 + vj)) * (theta - v0) + sigma^4 * (-3 * theta + v0) + kappa * sigma^2 * (4 * mu * theta - theta^2 + 8 * rho * sigma * (2 * theta - v0) - 
               3 * theta * v0 + 2 * v0^2) + 2 * kappa^2 * (theta * (-4 * sigma * (sigma + 2 * rho * (mu + rho * sigma)) - 2 * (mu - 2 * rho * sigma) * theta + theta^2) + 2 * (2 * sigma * (sigma + rho * (mu + rho * sigma)) + 2 * mu * theta - theta^2)*v0 + 
               (-2 * (mu + rho * sigma) + theta) * v0^2)) + exp(2 * t *kappa) * (6 * sigma^4 * theta + 2 * kappa^4 * lambda * vj^2 * (12 + vj) - 6 * kappa^2 * (2 * mu * (rho * sigma * (8 * theta - 4 * v0) + (theta- v0)^2) -                                                                                                            
               theta * ((4 + 8 * rho^2) * sigma^2 + 4 * rho * sigma * (3 * theta - 2 * v0) + (theta - v0)^2)) - 6 * kappa^3 * (8 * rho * sigma * theta + (8 * theta + lambda * vj * (4 + vj)) * (theta - v0) + 8 * mu * (-theta + v0)) - 
               3 * kappa * sigma^2 * (theta * (12 * rho * sigma + 7 * theta - 4 * v0) + mu * (-10 * theta + 4 * v0)))) - (-1 + exp(t * kappa)) * (-(sigma^4 * (theta - 3 * v0)) - 3 * kappa * sigma^2 * (theta - 2 * v0) * (theta - v0) -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
               2 * kappa^2 * (theta - v0)^3 + exp(t * kappa) * (theta * (sigma^2 + 2 * kappa * theta) * (-12 * kappa^2 - 7 * sigma^2 + 2 * kappa * (12 * rho * sigma + theta)) +3*(sigma^2 + 2 * kappa * theta) * (8 * kappa^2 + 3 * sigma^2 -  
               2 * kappa * (6 * rho * sigma + theta)) * v0 +  12 * kappa^2 * (-2 * kappa + 2 * rho * sigma + theta) * v0^2 - 4 * kappa^2 * v0^3) + exp(2 * t * kappa) * (24 * kappa^3 * (rho * sigma * (4 * theta - 2 * v0) + (theta - v0)^2) +                                                                                                                                      
               2 * sigma^4 * (-11 * theta + 3 * v0) + 3 * kappa * sigma^2 * (5 * theta^2 + 4 * rho * sigma * (10 * theta - 3 * v0) - 7 * theta * v0 + 2 * v0^2) - 2 * kappa^2 * ((theta - v0)^3 +                                                                                                                                                   
               6 * sigma^2 * (5 * theta + 12 * rho^2 * theta - 2 * v0 - 4 * rho^2 * v0) + 12 * rho * sigma * (2 * theta^2 - 3 * theta * v0 + v0^2)))) - 
               12 * t * exp(2 * t * kappa) * kappa^4 * lambda * vj * (-2 * theta + exp(t * kappa) * (kappa * (-4 + 4 * t * mu - 2 * t * theta - vj) + 2 * (theta - v0)) + 2 * v0) * log(1 + muj) +                                                                                                                                                            
               24 * t * exp(2 * t * kappa) * kappa^4 * lambda * (-theta + v0 - exp(t * kappa) * (-theta + t * kappa * (-2 * mu + theta) + kappa * vj + v0))* log(1 + muj)^2 +                                                                                                                                                           
               16 * t * exp(3 * t * kappa) * kappa^5 * lambda * log(1 + muj)^3)) / exp(3 * t * kappa) + (3 * sigma^6 * (theta - 4 * v0) + 4 * kappa^3 * (-theta + exp(t * kappa) * (t * kappa * (2 * mu - theta) + theta - v0) + v0)^4 + 
               12 * exp(2 * t * kappa) * sigma^2 * (sigma^4 * (7 * theta - 4 * v0) + 8 * kappa^4 * (1 + 2 * t * rho * sigma * (-2 + t * rho * sigma)) * (theta - 2*v0) + 2 * kappa * sigma^3 * (-24 * rho * theta + 5 * t * sigma * theta + 20 * rho * v0 - 6 * t * sigma * v0) +   
               4 * kappa^2 * sigma^2 * ((6 + 20 * rho^2 - 14 * t * rho * sigma + t^2 * sigma^2)*theta - 2 * (3 + 12 * rho^2 - 10 * t * rho * sigma + t^2 * sigma^2) * v0) - 
               8 * kappa^3 * sigma * ((-3 * t * sigma + 2 * rho * (4 + t * sigma * (-4 * rho + t * sigma))) * theta + 2 * (3 * t * sigma + 2 * rho * (-3 + t * sigma * (3 * rho - t * sigma))) * v0)) + 
               8 * exp(3 * t * kappa) * sigma^2 * (-16 * t^2 * kappa^6 * rho^2 * (-3 + t * rho * sigma) * (theta - v0) + 3 * sigma^4 * (7 * theta + 2 * v0) + 2 * kappa^3 * sigma * ((-192 * (rho + rho^3) + 6 * t * (9 + 40 * rho^2)*sigma - 
               42 * t^2 * rho * sigma^2 + t^3 * sigma^3) * theta + (48 * rho^3 - 18 * t * (1 + 4 * rho^2) * sigma + 24 * t^2 * rho * sigma^2 - t^3 * sigma^3) * v0) +                                               
               12 * kappa^4 * ((4 + 24 * rho^2 - 8 * t * rho * (4 + 3 * rho^2) * sigma + t^2 * (3 + 14 * rho^2) * sigma^2 - t^3 * rho * sigma^3) * theta + (-8 * rho^2 +  
               8 * t * rho * (2 + rho^2) * sigma - t^2 * (3 + 8 * rho^2) * sigma^2 + t^3 * rho * sigma^3) * v0) + 6 * kappa^2 * sigma^2 * ((15 + 80 * rho^2 - 35 * t * rho * sigma + 2 * t^2 * sigma^2)*theta + 
               (3 + t * sigma * (7 * rho - t * sigma)) * v0) + 24 * t * kappa^5 * ((2 + 8 * rho^2 - 4 * t * (rho + rho^3) * sigma + t^2 * rho^2 * sigma^2) * theta + (-2 + rho * (4 * t * sigma + rho * (-4 + t * sigma * (2 * rho - t * sigma)))) * v0) + 
               3 * kappa * sigma^3 * (t * sigma * (9 * theta - v0) - 10 * rho * (6 * theta + v0))) + 24 * exp(t * kappa) * sigma^4 * (-2 * kappa^2 * (-1 + t * rho * sigma) * (theta - 3 * v0) +                                                                                                                                 
               sigma^2 * (theta - 2 * v0) + kappa * sigma * (t * sigma * (theta - 3 * v0) + rho * (-4 * theta + 10 * v0))) +  exp(4 * t * kappa) * (192 * t * kappa^5 * (1 + 4 * rho^2) * sigma^2 * theta +                                                                                                                                                                                                                                                                                       
               4 * t * kappa^7 * lambda * vj^2 * (48 + vj * (24 + vj)) + 12 * kappa * sigma^5 * (5 * t * sigma * theta + 8 * rho * (22 * theta - 5 * v0)) + 3 * sigma^6 * (-93 * theta + 20 * v0) +  
               96 * kappa^3 * sigma^3 * ((3 * t * sigma + 4 * rho * (10 + 8 * rho^2 + 3 * t* rho * sigma)) * theta - 4 * rho * (3 + 2 * rho^2) * v0) - 96 * kappa^2 * sigma^4 * ((11 + 50 * rho^2 +                                                                                                                         
               5 * t * rho * sigma) * theta - 3 * (v0 + 4 * rho^2 * v0)) - 96 * kappa^4 * sigma^2 * ((5 + 4 * rho * (6 * rho + t * (3 + 2 * rho^2) * sigma)) * theta - 2 * (v0 + 4 * rho^2 * v0))) -                                                                                                                         
               32 * t * exp(4 * t * kappa) * kappa^7 * lambda * vj^2 * (12 + vj) * log(1 + muj) + 96 * t * exp(4 * t * kappa) * kappa^7 * lambda * vj * (4 + vj) * log(1 + muj)^2 - 
               128 * t * exp(4 * t * kappa) * kappa^7 * lambda * vj * log(1 + muj)^3 + 64 * t * exp(4 * t * kappa) * kappa^7 * lambda * log(1+ muj)^4 +  
               12 * kappa^2 * (-theta + exp(t * kappa) * (t * kappa * (2 * mu - theta) + theta - v0) + v0)^2 * (sigma^2 * (theta - 2 * v0) + exp(2 * t * kappa) * (2 * t* kappa^3 * (4 * theta + lambda * vj*(4 + vj)) - 
               8 * kappa^2 * (theta + t * rho * sigma * theta - v0) + sigma^2 * (-5 * theta + 2 * v0) + 2 * kappa * sigma * (8 * rho * theta + t * sigma * theta - 4 * rho * v0)) + 
               4 * exp(t * kappa) * (sigma^2 * theta - 2 * kappa^2 * (-1 + t * rho * sigma) * (theta - v0) + kappa * sigma * (t * sigma * (theta - v0) + 2 * rho * (-2 * theta + v0))) -  
               8 * t * exp(2 * t * kappa) * kappa^3 * lambda * (vj - log(1 + muj)) * log(1 + muj)) + 3 * kappa * (sigma^2 * (theta - 2 * v0) + exp(2 * t * kappa) * (2 * t * kappa^3 * (4 * theta + lambda * vj * (4 + vj)) - 
               8 * kappa^2 * (theta + t * rho * sigma * theta - v0) + sigma^2 * (-5 * theta + 2 * v0) + 2 * kappa * sigma * (8 * rho * theta + t * sigma * theta - 4 * rho * v0)) +   
               4 * exp(t * kappa) * (sigma^2 * theta - 2 * kappa^2 * (-1 + t * rho * sigma) * (theta - v0) + kappa * sigma * (t * sigma * (theta - v0) + 2 * rho * (-2 * theta + v0))) - 
               8 * t * exp(2 * t * kappa) * kappa^3 * lambda * (vj - log(1 + muj))*log(1 + muj))^2  - 8 * kappa * (-theta + exp(t * kappa) * (t * kappa * (2 * mu - theta) + theta - v0) + v0) *  
               (sigma^4 * (theta - 3 * v0) + 3 * exp(2 * t * kappa) * sigma * ((-16 * kappa^3 * (2 + t * kappa) * rho + 8 * kappa^2 * (2 + 2 * t * kappa + (6 + t * kappa * (4 + t * kappa)) * rho^2)*sigma -  
               8 * kappa * (2 + t * kappa)^2 * rho * sigma^2 + (5 + 2 * t * kappa * (3 + t * kappa)) * sigma^3) * theta + (16 * kappa^3 * (1 + t * kappa) * rho -  
               8 * kappa^2 * (2 * t * kappa + (2 + t * kappa * (2 + t * kappa)) * rho^2)*sigma + 8 * t * kappa^2 * (2 + t * kappa) * rho * sigma^2 + (1 - 2 * t * kappa * (1 + t * kappa)) * sigma^3) * v0) +                                                                                                             
               6 * exp(t * kappa) * sigma^2 * (-2 * kappa^2 * (-1 + t * rho * sigma) * (theta - 2 * v0) + sigma^2 * (theta - v0) + kappa * sigma * (t * sigma * (theta - 2 * v0) + rho * (-4 * theta + 6 * v0))) +                                                                                                                
               2 * exp(3 * t * kappa) * (-24 * t * kappa^4 * rho * sigma * theta + t * kappa^5 * lambda * vj^2 * (12 + vj) + sigma^4 * (-11 * theta + 3 * v0) + 3 * kappa * sigma^3 * (20 * rho * theta + t * sigma * theta - 6 * rho * v0) + 
               12 * kappa^3 * sigma * (4 * rho * theta + t * sigma * theta + 2 * t * rho^2 * sigma * theta - 2 * rho * v0) - 6 * kappa^2 * sigma^2 *((5 + 3 * rho * (4 * rho + t * sigma)) * theta - 2 * (v0 + 2 * rho^2 * v0))) -  
               4 * t * exp(3 * t * kappa) * kappa^5 * lambda * log(1 + muj) * (3 * vj * (4 + vj) - 6 * vj * log(1 + muj) + 4 * log(1 + muj)^2))) / exp(4 * t * kappa)))/
               (kappa * (sigma^2 * (theta - 2 * v0) + exp(2 * t * kappa) * (2 * t * kappa^3 * (4 * theta + lambda * vj * (4 + vj)) - 8 * kappa^2 * (theta + t * rho * sigma * theta - v0) +  
               sigma^2 * (-5 * theta + 2 * v0) + 2 * kappa * sigma * (8 * rho * theta + t * sigma * theta - 4 * rho * v0)) + 4 * exp(t * kappa) * (sigma^2 * theta - 2 * kappa^2 * (-1 + t * rho * sigma) * (theta - v0) +                                                                 
               kappa * sigma * (-4 * rho * theta + t * sigma * theta + 2 * rho * v0 - t * sigma * v0)) - 8 * t * exp(2 * t * kappa) * kappa^3 * lambda * vj * log(1 + muj) +  8 * t * exp(2 * t * kappa) * kappa^3 * lambda * log(1 + muj)^2)^2)                                                                  
   
    res = c(Ert1.v0, Ert2.v0, Ert3.v0, Ert4.v0, Varrt.v0, Skewrt.v0, Kurtrt.v0); names(res) = c("Ert.v0", "Ert2.v0", "Ert3.v0", "Ert4.v0", "Varrt.v0", "Skewrt.v0", "Kurtrt.v0")
    
  }else{
    
    Ert1 = (mu - theta / 2) * t
  
    
    Ert2 = (sigma * (- 4 * kappa * rho + sigma) * theta + exp(kappa * t) * (- (sigma^2 * theta) - 4 * kappa^2 * rho * sigma * t * theta + kappa * sigma * (4 * rho + sigma * t) * theta +
           kappa^3 * t * (4 * theta + t * (-2 * mu + theta)^2 + lambda * vj * (4 + vj)) + 4 * kappa^3 * lambda * t * log(1 + muj) * (-vj + log(1 + muj)))) / (4 * exp(kappa * t) * kappa^3)
  
    
    Ert3 =  (- 3 * sigma * theta * (2 * sigma^3 + kappa * sigma^2 * (- 12 * rho + sigma * t) + 4 * kappa^3 * rho*(- 2 + 2 * mu * t + 2 * rho * sigma * t - t * theta) + 
            kappa^2 * sigma * (4 + 16 * rho^2 - 2 * mu * t - 6 * rho * sigma * t + t * theta)) + 
            exp(kappa * t) * (6 * sigma^4 * theta - 3 * kappa * sigma^3 * (12 * rho + sigma * t) * theta + 12 * kappa^4 * rho * sigma * t * theta * (2 - 2 * mu * t + t * theta) + 
            3 * kappa^2 * sigma^2 * theta * (4 + 16 * rho^2 - 2 * mu * t + 6 * rho * sigma * t + t * theta) - 
            3 * kappa^3 * sigma * theta * (8 * rho^2 * sigma * t + sigma * t * (4 - 2 * mu * t + t * theta) + rho * (8 - 8 * mu * t + 4 * t * theta)) + 
            kappa^5 * t * (t * (2 * mu - theta) * (12 * theta + t * (- 2 * mu + theta)^2) + 12 * lambda * t * (2 * mu - theta) * vj + 3 * lambda * (- 4 + 2 * mu * t - t * theta) * vj^2 - 
            lambda * vj^3)) + 2 * exp(kappa * t) * kappa^5 * lambda * t * log(1 + muj) *
            (3 * vj * (4 - 4 * mu * t + 2 * t * theta + vj) - 6 * (-2 * mu * t + t * theta + vj) * log(1 + muj) + 4 * log(1 + muj)^2)) / (8 * exp(kappa * t) * kappa^5)
  
    
    
    Ert4 = (( - 24 * kappa^2 * (2 * kappa * rho - sigma) * sigma * t * (2 * (- 1 + exp(kappa * t)) * sigma^2 - kappa * sigma * (8 * (- 1 + exp(kappa * t)) * rho + sigma * t) 
           + 4 * kappa^2 * (- 1 + exp(kappa * t) + rho * sigma * t)) * (2 * mu - theta) * theta)/exp(kappa * t) + (3 * sigma^2 * theta * ((-4 * kappa*rho + sigma)^2 * 
           (sigma^2 + 2 * kappa * theta) + exp(2 * kappa * t) * (- 32 * kappa^4 * (1 + 8 * rho^2) - 29 * sigma^4 + 2 * kappa * sigma^2 * (116 * rho * sigma + theta) - 
           16 * kappa^2 * sigma * (6 * sigma + 35 * rho^2 * sigma + rho * theta) + 32 * kappa^3 * rho * (12 * (1 + rho^2) * sigma + rho * theta)) - 
           4 * exp(kappa * t) * (- 7 * sigma^4 + 16 * kappa^5 * rho^2 * t * (-2 + rho * sigma * t) + 4 * kappa^4 * (- 2 + rho * (12 * sigma*t +
           rho * (- 16 + sigma * t * (16 * rho - 5 * sigma * t)))) + kappa * sigma^2 * (56 * rho * sigma - 5 * sigma^2 * t + theta) - 
           kappa^2 * sigma * (sigma * (24 + 136 * rho^2 - 40 * rho * sigma * t + sigma^2 * t^2) + 8 * rho * theta) + 
           4 * kappa^3 * (sigma * (24 * (rho + rho^3) - 3 * (1 + 8 * rho^2) * sigma * t + 2 * rho * sigma^2 * t^2) + 4 * rho^2 * theta))))/
           exp(2 * kappa * t) + (12 * (- 1 + exp(kappa * t)) * kappa^2 * (4 * kappa * rho - sigma) * sigma * t * theta * (- 4 * kappa * rho * sigma * theta + 
           sigma^2 * theta + kappa^2 * (4 * theta + t * (- 2 * mu + theta)^2 + lambda * vj * (4 + vj)) + 4 * kappa^2 * lambda * log(1 + muj) * (- vj + log(1 + muj)))) / exp(kappa * t) + 
           2 * kappa * t * (- 120 * kappa * rho * sigma^5 * theta + 15 * sigma^6 * theta - 48 * kappa^3 * rho * sigma^3 * theta * (6 + 4 * rho^2 - 3 * mu * t + 2 * t * theta) + 
           3 * kappa^2 * sigma^4 * theta * (24 + 96 * rho^2 - 8 * mu * t + 5 * t * theta) + kappa^6 * (t * (16 * mu^4 * t^2 - 32 * mu^2 * t * (- 3 + mu * t) * theta +
           24 * (2 + mu * t * (- 4 + mu * t)) * theta^2 - 8 * t * (- 3 + mu * t) * theta^3 + t^2 * theta^4) + 24 * lambda * t * (4 * theta + t * (- 2 * mu + theta)^2) * vj + 
           6 * lambda * (8 + t * (8 * lambda + 4 * mu^2 * t - 4 * mu*(4 + t * theta) + theta * (12 + t * theta))) * vj^2 + 4 * lambda * (6 + t * (6 * lambda - 2 * mu + theta)) * vj^3 + 
           lambda * (1 + 3 * lambda * t) * vj^4) - 24 * kappa^5 * rho * sigma * t * theta * (4 * mu^2 * t - 4 * mu * (2 + t * theta) + theta * (8 + t * theta) + lambda * vj * (4 + vj)) + 
           6 * kappa^4 * sigma^2 * theta * (8 - 16 * mu * t + 8 * rho^2 * (4 - 4 * mu * t + 3 * t * theta) + t * (12 * theta + t * (- 2 * mu + theta)^2 + lambda * vj * (4 + vj))) + 
           8 * kappa^4 * lambda * log(1 + muj) * (vj * (12 * kappa * rho * sigma * t * theta - 3 * sigma^2 * t * theta + 
           kappa^2 * (- 12 * mu^2 * t^2 - 3 * t * theta * (8 + t * theta) - 3 * (4 + 4 * lambda * t + t * theta) * vj - (1 + 3 * lambda * t) * vj^2 + 
           6 * mu * t*(4 + 2 * t * theta + vj))) + log(1 + muj) * (3 * (- 4 * kappa * rho * sigma * t * theta + sigma^2 * t * theta + 
           kappa^2 * (t * (4 * theta + t * (-2 * mu + theta)^2) + 2 * (2 + t * (2 * lambda - 2 * mu + theta)) * vj + (1 + 3 * lambda * t) * vj^2)) + 
           2 * kappa^2 * log(1 + muj) * (- 2 * (vj + t * (- 2 * mu + theta + 3 * lambda * vj)) + (1 + 3 * lambda * t) * log(1 + muj)))))) / (32 * kappa^7)
      
    
    
    Skewrt = (- 3 * (2 * kappa * rho - sigma) * sigma * (- 2 * sigma^2 + kappa * sigma * (8 * rho - sigma * t) + 4 * kappa^2 * (- 1 + rho * sigma * t)) * theta - 
             exp(kappa * t) * (- 3 * (2 * kappa * rho - sigma) * sigma * (- 2 * sigma^2 + 4 * kappa^3 * t + kappa * sigma * (8 * rho + sigma * t) - 
             4 * kappa^2 * (1 + rho * sigma * t)) * theta + 12 * kappa^5 * lambda * t * vj^2 + kappa^5 * lambda * t * vj^3) + 
             2 * exp(kappa * t) * kappa^5 * lambda * t * log(1 + muj) * (3 * vj * (4 + vj) - 6 * vj * log(1 + muj) + 4 * log(1 + muj)^2)) /
             (exp(kappa * t) * kappa^5 * (((- 1 + exp(- kappa * t)) * sigma^2 * theta - 4 * kappa^2 * rho * sigma * t * theta + 
             kappa * sigma * ((4 - 4 / exp(kappa * t)) * rho + sigma * t) * theta + kappa^3 * t * (4 * theta + lambda * vj * (4 + vj))) / kappa^3 - 
             4 * lambda * t * vj * log(1 + muj) + 4 * lambda * t * log(1 + muj)^2)^1.5)
      
  
    
    Kurtrt = (3 * sigma^2 * (- 4 * kappa * rho + sigma)^2 * theta * (sigma^2 + 2 * kappa * theta) + 12 * exp(kappa * t) * sigma * theta * (7 * sigma^5 - 
             kappa * sigma^3 * (56 * rho*sigma - 5 * sigma^2 * t + theta) + kappa^2 * sigma^2 * (- 40 * rho * sigma^2 * t + sigma^3 * t^2 + 
             8 * rho * theta + sigma * (24 + 136 * rho^2 + t * theta)) - 4 * kappa^3 * sigma * (24 * rho^3 * sigma - 3 * sigma^2 * t + 4 * rho^2 * (- 6 * sigma^2 * t + theta) + 
             2 * rho * sigma * (12 + sigma^2 * t^2 + t * theta)) - 4 * kappa^5 * rho * t * (- 8 * rho * sigma + 4 * rho^2 * sigma^2 * t + 4 * theta + lambda * vj * (4 + vj)) + 
             kappa^4 * sigma * (8 - 48 * rho * sigma * t - 64 * rho^3 * sigma * t + 4 * rho^2 * (16 + 5 * sigma^2 * t^2 + 4 * t * theta) + t * (4 * theta + lambda * vj * (4 + vj)))) + 
             exp(2 * kappa * t) * (- 87 * sigma^6 * theta + 6 * kappa * sigma^4 * theta * (116 * rho * sigma + 5 * sigma^2 * t + theta) + 6 * kappa^3 * sigma^2 * theta * (192 * rho^3 * sigma + 
             16 * rho^2 * (6 * sigma^2 * t + theta) + 16 * rho * sigma * (12 + t * theta) + sigma^2 * t * (24 + t*theta)) - 12 * kappa^2 * sigma^3 * theta * (20 * rho * sigma^2 * t + 
             4 * rho * theta + sigma * (24 + 140 * rho^2 + t * theta)) - 48 * kappa^6 * rho * sigma * t^2 * theta * (4 * theta + lambda * vj * (4 + vj)) - 
             12 * kappa^4 * sigma^2 * theta * (8 + 32 * rho^3 * sigma * t + 16 * rho^2 * (4 + t * theta) + 4 * rho * sigma * t * (12 + t * theta) + 
             t * (4 * theta + lambda * vj * (4 + vj))) + 2 * kappa^7 * t * (lambda * vj^2 * (48 + 24 * vj + vj^2) + 3 * t * (4 * theta + lambda * vj * (4 + vj))^2) + 
             12 * kappa^5 * sigma * t * theta * (4 * rho * (4 * theta + lambda * vj * (4 + vj)) + sigma * (8 + 8 * rho^2 * (4 + t * theta) + t * (4 * theta + lambda * vj * (4 + vj))))) - 
             16 * exp(kappa * t) * kappa^4 * lambda * t * vj * (- 3 * (- 1 + exp(kappa * t)) * sigma^2 * theta - 12 * exp(kappa * t) * kappa^2 * rho * sigma * t * theta + 
             3 * kappa * sigma * (4 * (- 1 + exp(kappa * t)) * rho + exp(kappa * t) * sigma * t) * theta + exp(kappa * t) * kappa^3 * (vj * (12 + vj) +
             3 * t * (4 * theta + lambda * vj * (4 + vj)))) * log(1 + muj) + 48 * exp(kappa * t) * kappa^4 * lambda * t * ((1 - exp(kappa * t)) * sigma^2 * theta - 
             4 * exp(kappa * t) * kappa^2 * rho * sigma * t * theta + kappa * sigma * (4 * (- 1 + exp(kappa * t)) * rho + exp(kappa * t) * sigma * t) * theta + 
             exp(kappa * t) * kappa^3 * (vj * (4 + vj) + t * (4 * theta + lambda * vj * (4 + 3 * vj)))) * log(1 + muj)^2 - 
             64 * exp(2 * kappa * t) * kappa^7 * lambda * t * (1 + 3 * lambda * t) * vj * log(1 + muj)^3 + 32 * exp(2 * kappa * t) * kappa^7 * lambda * t * (1 + 3 * lambda * t) * log(1 + muj)^4) /
             (2 * exp(2 * kappa * t) * kappa^7 * (((- 1 + exp(- kappa * t)) * sigma^2 * theta - 4 * kappa^2 * rho * sigma * t * theta + 
             kappa * sigma * ((4 - 4 / exp(kappa * t)) * rho + sigma * t) * theta + kappa^3 * t * (4 * theta + lambda * vj * (4 + vj))) / kappa^3 - 4 * lambda * t * vj * log(1 + muj) + 
             4 * lambda * t * log(1 + muj)^2)^2)
      
    
    res = c(Ert1, Ert2, Ert3, Ert4, Skewrt, Kurtrt); names(res) = c("Ert", "Ert2", "Ert3", "Ert4", "Skewrt", "Kurtrt")
  
  }  
   
  return(res)  
  
}

# Examples:

# Compute first 4 conditional moments
MomentsCIR(p = 1:4, kappa = 3, theta = 0.19, sigma = 0.4, v0 = 0.1, t = 1/250)

# Compute first 4 unconditional moments
MomentsCIR(p = 1:4, kappa = 3, theta = 0.19, sigma = 0.4, conditional = F)

# Compute all combination of (p,q)-th conditonal comoment
MomentsCIR(p = 1:4, q = 1:4, kappa = 3, theta = 0.19, sigma = 0.4, v0 = 0.1, t = 1/250, comoments = T)

# Compute all combination of (p,q)-th unconditonal comoment
MomentsCIR(p = 1:4, q = 1:4, kappa = 3, theta = 0.19, sigma = 0.4, t = 1/250, conditional = F, comoments = T)

# Compute first four conditional moments as well as varaince, skewness and kurtosis for 1-day log-returns
MomentsBates(mu = 0, kappa = 3, theta = 0.19, sigma = 0.4, rho = -0.7, lambda = 20, muj = 0, vj = 0.1, t = 1/250, v0 = 0.1)

# Compute first four unconditional moments as well as skewness and kurtosis for 1-day log-returns
MomentsBates(mu = 0, kappa = 3, theta = 0.19, sigma = 0.4, rho = -0.7, lambda = 20, muj = 0, vj = 0.1, t = 1/250, conditional = F)
